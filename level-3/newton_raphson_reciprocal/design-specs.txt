```txt
Design Name:
- reciprocal_newton_raphson_fixedpoint

Module Name:
- reciprocal_newton_raphson_fixedpoint

Inputs:
- X [n-1:0]: The input number for which the reciprocal is to be calculated, represented in fixed-point format (n-bit unsigned, with `m` fractional bits).
- clk: Clock signal (used for sequential implementation).
- rst: Reset signal (synchronously or asynchronously clears internal registers).
- start: Start signal that triggers the latching of the input X and initiates a new reciprocal computation.

Outputs:
- reciprocal_result [n-1:0]: The calculated reciprocal of the input number, represented in fixed-point format (n-bit unsigned, with `m` fractional bits).
- ready: Status flag indicating the completion of the reciprocal computation.

Design Signature:
module reciprocal_newton_raphson_fixedpoint(
    input clk,
    input rst,
    input start,
    input [n-1:0] X,
    output reg [n-1:0] reciprocal_result,
    output reg ready
);

Design Notes:
- Implements Newton-Raphson’s iterative method for reciprocal calculation using the formula: yₙ₊₁ = yₙ × (2 - X × yₙ), adapted for fixed-point arithmetic.
- The algorithm first normalizes the input X so that it falls within a convergence-friendly range (typically [0.5, 1) in real numbers, or [1<<(m-1), 1<<m) in fixed-point representation). This is necessary because the iterative method converges reliably only when X is normalized.
- After latching X on the activation of the start signal, the module checks X for zero. If X is nonzero, normalization is performed (by shifting right if X is too large, or left if X is too small). An internal shift_count is maintained to track the amount of normalization applied.
- An initial guess for the reciprocal is then set in the normalized domain. Instead of simply initializing to 1.0 (i.e. 1 << m), an initial guess is computed as:
      y₀ = (3 << m) - X_norm
  This calculation is based on the already computed normalized input.
- The iterative process is controlled by a finite state machine (FSM) with the following states:
  - IDLE: Waits for the start signal. When received, it latches the input X.
  - NORM: Performs normalization on X until it falls into the desired normalized range. The original X is preserved, and a shift_count is maintained to record the normalization.
  - CALC: Executes a predefined number of Newton-Raphson iterations (using yₙ₊₁ = yₙ × (2 - X_norm × yₙ)) to compute the reciprocal of the normalized input (X_norm). Intermediate calculations are done with extended bit width (n+m bits) to avoid overflow.
  - DONE: Adjusts the computed reciprocal back to the original scale using the recorded shift_count. The mathematical relationship is:
      Reciprocal of original X = (Reciprocal computed from X_norm) re-scaled by the appropriate factor.
      - If X was normalized by right shifting (i.e. X was too large and divided by 2^shift_count), then the computed reciprocal must be shifted right (divided) by shift_count.
      - If X was normalized by left shifting (i.e. X was too small and multiplied by 2^shift_count), then the computed reciprocal must be shifted left (multiplied) by shift_count.
- The module outputs the final reciprocal once it has converged and remains in the DONE state (asserting ready), until a new computation is started upon reset.
- The design is parameterized to support various fixed-point formats (different bit-widths and numbers of fractional bits) for flexible integration.
- The normalization and re-adjustment ensure that the initial guess is optimal for the iterative process and that the final result reflects the correct reciprocal of the original, non-normalized input.
```